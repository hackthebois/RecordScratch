import { format } from './sanitization.js';
export { format } from './sanitization.js';
import { decode, uint8Array } from './text.js';
export { hex } from './text.js';
import { Version } from './version.js';
export class DatabaseError extends Error {
    constructor(message, status, body) {
        super(message);
        this.status = status;
        this.name = 'DatabaseError';
        this.body = body;
    }
}
export class Client {
    constructor(config) {
        this.config = config;
    }
    async transaction(fn) {
        return this.connection().transaction(fn);
    }
    async execute(query, args = null, options = { as: 'object' }) {
        return this.connection().execute(query, args, options);
    }
    connection() {
        return new Connection(this.config);
    }
}
class Tx {
    constructor(conn) {
        this.conn = conn;
    }
    async execute(query, args = null, options = { as: 'object' }) {
        return this.conn.execute(query, args, options);
    }
}
function protocol(protocol) {
    return protocol === 'http:' ? protocol : 'https:';
}
function buildURL(url) {
    const scheme = `${protocol(url.protocol)}//`;
    return new URL(url.pathname, `${scheme}${url.host}`).toString();
}
export class Connection {
    constructor(config) {
        this.config = config;
        this.fetch = config.fetch || fetch;
        this.session = null;
        if (config.url) {
            const url = new URL(config.url);
            this.config.username = url.username;
            this.config.password = url.password;
            this.config.host = url.hostname;
            this.url = buildURL(url);
        }
        else {
            this.url = new URL(`https://${this.config.host}`).toString();
        }
    }
    async transaction(fn) {
        const conn = new Connection(this.config);
        const tx = new Tx(conn);
        try {
            await tx.execute('BEGIN');
            const res = await fn(tx);
            await tx.execute('COMMIT');
            return res;
        }
        catch (err) {
            await tx.execute('ROLLBACK');
            throw err;
        }
    }
    async refresh() {
        await this.createSession();
    }
    async execute(query, args = null, options = { as: 'object' }) {
        const url = new URL('/psdb.v1alpha1.Database/Execute', this.url);
        const formatter = this.config.format || format;
        const sql = args ? formatter(query, args) : query;
        const saved = await postJSON(this.config, this.fetch, url, {
            query: sql,
            session: this.session
        });
        const { result, session, error, timing } = saved;
        if (session) {
            this.session = session;
        }
        if (error) {
            throw new DatabaseError(error.message, 400, error);
        }
        const rowsAffected = result?.rowsAffected ? parseInt(result.rowsAffected, 10) : 0;
        const insertId = result?.insertId ?? '0';
        const fields = result?.fields ?? [];
        for (const field of fields) {
            field.type || (field.type = 'NULL');
        }
        const castFn = options.cast || this.config.cast || cast;
        const rows = result ? parse(result, castFn, options.as || 'object') : [];
        const headers = fields.map((f) => f.name);
        const typeByName = (acc, { name, type }) => ({ ...acc, [name]: type });
        const types = fields.reduce(typeByName, {});
        const timingSeconds = timing ?? 0;
        return {
            headers,
            types,
            fields,
            rows,
            rowsAffected,
            insertId,
            size: rows.length,
            statement: sql,
            time: timingSeconds * 1000
        };
    }
    async createSession() {
        const url = new URL('/psdb.v1alpha1.Database/CreateSession', this.url);
        const { session } = await postJSON(this.config, this.fetch, url);
        this.session = session;
        return session;
    }
}
async function postJSON(config, fetch, url, body = {}) {
    const auth = btoa(`${config.username}:${config.password}`);
    const response = await fetch(url.toString(), {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
            'Content-Type': 'application/json',
            'User-Agent': `database-js/${Version}`,
            Authorization: `Basic ${auth}`
        },
        cache: 'no-store'
    });
    if (response.ok) {
        return await response.json();
    }
    else {
        let error = null;
        try {
            const e = (await response.json()).error;
            error = new DatabaseError(e.message, response.status, e);
        }
        catch {
            error = new DatabaseError(response.statusText, response.status, {
                code: 'internal',
                message: response.statusText
            });
        }
        throw error;
    }
}
export function connect(config) {
    return new Connection(config);
}
function parseArrayRow(fields, rawRow, cast) {
    const row = decodeRow(rawRow);
    return fields.map((field, ix) => {
        return cast(field, row[ix]);
    });
}
function parseObjectRow(fields, rawRow, cast) {
    const row = decodeRow(rawRow);
    return fields.reduce((acc, field, ix) => {
        acc[field.name] = cast(field, row[ix]);
        return acc;
    }, {});
}
function parse(result, cast, returnAs) {
    const fields = result.fields ?? [];
    const rows = result.rows ?? [];
    return rows.map((row) => returnAs === 'array' ? parseArrayRow(fields, row, cast) : parseObjectRow(fields, row, cast));
}
function decodeRow(row) {
    const values = row.values ? atob(row.values) : '';
    let offset = 0;
    return row.lengths.map((size) => {
        const width = parseInt(size, 10);
        if (width < 0)
            return null;
        const splice = values.substring(offset, offset + width);
        offset += width;
        return splice;
    });
}
export function cast(field, value) {
    if (value == null) {
        return value;
    }
    switch (field.type) {
        case 'INT8':
        case 'INT16':
        case 'INT24':
        case 'INT32':
        case 'UINT8':
        case 'UINT16':
        case 'UINT24':
        case 'UINT32':
        case 'YEAR':
            return parseInt(value, 10);
        case 'FLOAT32':
        case 'FLOAT64':
            return parseFloat(value);
        case 'DECIMAL':
        case 'INT64':
        case 'UINT64':
        case 'DATE':
        case 'TIME':
        case 'DATETIME':
        case 'TIMESTAMP':
            return value;
        case 'BLOB':
        case 'BIT':
        case 'GEOMETRY':
            return uint8Array(value);
        case 'BINARY':
        case 'VARBINARY':
            return isText(field) ? value : uint8Array(value);
        case 'JSON':
            return value ? JSON.parse(decode(value)) : value;
        default:
            return decode(value);
    }
}
var Flags;
(function (Flags) {
    Flags[Flags["NONE"] = 0] = "NONE";
    Flags[Flags["ISINTEGRAL"] = 256] = "ISINTEGRAL";
    Flags[Flags["ISUNSIGNED"] = 512] = "ISUNSIGNED";
    Flags[Flags["ISFLOAT"] = 1024] = "ISFLOAT";
    Flags[Flags["ISQUOTED"] = 2048] = "ISQUOTED";
    Flags[Flags["ISTEXT"] = 4096] = "ISTEXT";
    Flags[Flags["ISBINARY"] = 8192] = "ISBINARY";
})(Flags || (Flags = {}));
function isText(field) {
    return ((field.flags ?? 0) & Flags.ISTEXT) === Flags.ISTEXT;
}
